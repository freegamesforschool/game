<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Race Survival: Arena King – Pure WebGL</title>
<style>
  * { margin:0; padding:0; box-sizing:border-box; }
  body { background:#000; overflow:hidden; color:#fff; font-family:system-ui; }
  #hud {
    position:fixed; top:10px; left:50%; transform:translateX(-50%);
    font-size:14px; text-shadow:0 0 4px #000;
    z-index:10;
  }
  canvas { display:block; width:100vw; height:100vh; }
</style>
</head>
<body>
<div id="hud">WASD/Arrows to drive – survive as long as you can</div>
<canvas id="glcanvas"></canvas>

<script>
// ====== Basic setup ======
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) { alert("WebGL not supported"); }

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, canvas.width, canvas.height);
}
window.addEventListener("resize", resize);
resize();

// ====== Shaders ======
const vsSource = `
attribute vec3 aPosition;
attribute vec3 aColor;
uniform mat4 uMVP;
varying vec3 vColor;
void main(void) {
  gl_Position = uMVP * vec4(aPosition, 1.0);
  vColor = aColor;
}
`;

const fsSource = `
precision mediump float;
varying vec3 vColor;
void main(void) {
  gl_FragColor = vec4(vColor, 1.0);
}
`;

function createShader(type, src) {
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(s));
  }
  return s;
}

const vs = createShader(gl.VERTEX_SHADER, vsSource);
const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
  console.error(gl.getProgramInfoLog(program));
}
gl.useProgram(program);

// ====== Simple mat4 utilities ======
function mat4Identity() {
  return [1,0,0,0,
          0,1,0,0,
          0,0,1,0,
          0,0,0,1];
}
function mat4Multiply(a,b) {
  const r = new Array(16);
  for (let i=0;i<4;i++) {
    for (let j=0;j<4;j++) {
      r[i*4+j] =
        a[i*4+0]*b[0*4+j] +
        a[i*4+1]*b[1*4+j] +
        a[i*4+2]*b[2*4+j] +
        a[i*4+3]*b[3*4+j];
    }
  }
  return r;
}
function mat4Perspective(fovy, aspect, near, far) {
  const f = 1.0 / Math.tan(fovy/2);
  const nf = 1 / (near - far);
  return [
    f/aspect, 0, 0, 0,
    0, f, 0, 0,
    0, 0, (far+near)*nf, -1,
    0, 0, (2*far*near)*nf, 0
  ];
}
function mat4Translate(m, v) {
  const [x,y,z] = v;
  const t = mat4Identity();
  t[12]=x; t[13]=y; t[14]=z;
  return mat4Multiply(m,t);
}
function mat4RotateY(m, rad) {
  const c = Math.cos(rad), s = Math.sin(rad);
  const r = [
    c,0,-s,0,
    0,1, 0,0,
    s,0, c,0,
    0,0, 0,1
  ];
  return mat4Multiply(m,r);
}
function mat4LookAt(eye, center, up) {
  const [ex,ey,ez]=eye, [cx,cy,cz]=center, [ux,uy,uz]=up;
  let zx = ex-cx, zy = ey-cy, zz = ez-cz;
  let len = Math.hypot(zx,zy,zz); zx/=len; zy/=len; zz/=len;
  let xx = uy*zz - uz*zy;
  let xy = uz*zx - ux*zz;
  let xz = ux*zy - uy*zx;
  len = Math.hypot(xx,xy,xz); xx/=len; xy/=len; xz/=len;
  let yx = zy*xz - zz*xy;
  let yy = zz*xx - zx*xz;
  let yz = zx*xy - zy*xx;
  len = Math.hypot(yx,yy,yz); yx/=len; yy/=len; yz/=len;
  const out = [
    xx, yx, zx, 0,
    xy, yy, zy, 0,
    xz, yz, zz, 0,
    0,  0,  0,  1
  ];
  out[12] = -(xx*ex + xy*ey + xz*ez);
  out[13] = -(yx*ex + yy*ey + yz*ez);
  out[14] = -(zx*ex + zy*ey + zz*ez);
  return out;
}

// ====== Geometry (cube + ground) ======
function createCube(size, color) {
  const s = size/2;
  const [r,g,b] = color;
  const positions = [
    // Front
    -s,-s, s,  s,-s, s,  s, s, s,  -s, s, s,
    // Back
    -s,-s,-s, -s, s,-s,  s, s,-s,  s,-s,-s,
    // Top
    -s, s,-s, -s, s, s,  s, s, s,  s, s,-s,
    // Bottom
    -s,-s,-s,  s,-s,-s,  s,-s, s, -s,-s, s,
    // Right
     s,-s,-s,  s, s,-s,  s, s, s,  s,-s, s,
    // Left
    -s,-s,-s, -s,-s, s, -s, s, s, -s, s,-s
  ];
  const colors = [];
  for (let i=0;i<24;i++) colors.push(r,g,b);
  const indices = [
    0,1,2, 0,2,3,
    4,5,6, 4,6,7,
    8,9,10, 8,10,11,
    12,13,14, 12,14,15,
    16,17,18, 16,18,19,
    20,21,22, 20,22,23
  ];
  return {positions, colors, indices};
}

function createGround(size, color) {
  const s = size;
  const [r,g,b] = color;
  const positions = [
    -s,0,-s,  s,0,-s,  s,0, s,  -s,0, s
  ];
  const colors = [r,g,b, r,g,b, r,g,b, r,g,b];
  const indices = [0,1,2, 0,2,3];
  return {positions, colors, indices};
}

function createBuffer(geom) {
  const posBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, posBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.positions), gl.STATIC_DRAW);

  const colBuf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, colBuf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(geom.colors), gl.STATIC_DRAW);

  const idxBuf = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, idxBuf);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(geom.indices), gl.STATIC_DRAW);

  return {posBuf, colBuf, idxBuf, count: geom.indices.length};
}

const carGeom = createCube(1, [0.2,0.8,1.0]);
const enemyGeom = createCube(1, [1.0,0.2,0.2]);
const groundGeom = createGround(20, [0.1,0.5,0.1]);

const carMesh = createBuffer(carGeom);
const enemyMesh = createBuffer(enemyGeom);
const groundMesh = createBuffer(groundGeom);

// Attributes/uniforms
const aPosition = gl.getAttribLocation(program, "aPosition");
const aColor = gl.getAttribLocation(program, "aColor");
const uMVP = gl.getUniformLocation(program, "uMVP");

// ====== Game state ======
let car = {
  x:0, z:0, y:0.5,
  rot:0,
  speed:0,
  maxSpeed:0.15,
  accel:0.004,
  friction:0.96,
  turnSpeed:0.06
};

const arenaRadius = 18;

let enemies = [];
function spawnEnemy() {
  const angle = Math.random()*Math.PI*2;
  const dist = 10 + Math.random()*7;
  enemies.push({
    x: Math.cos(angle)*dist,
    z: Math.sin(angle)*dist,
    y:0.5,
    vx: (Math.random()*0.04-0.02),
    vz: (Math.random()*0.04-0.02)
  });
}
for (let i=0;i<8;i++) spawnEnemy();

let keys = {};
window.addEventListener("keydown", e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener("keyup", e => { keys[e.key.toLowerCase()] = false; });

let lastTime = 0;
let alive = true;
let startTime = performance.now();
const hud = document.getElementById("hud");

// ====== Draw helpers ======
function bindMesh(mesh) {
  gl.bindBuffer(gl.ARRAY_BUFFER, mesh.posBuf);
  gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aPosition);

  gl.bindBuffer(gl.ARRAY_BUFFER, mesh.colBuf);
  gl.vertexAttribPointer(aColor, 3, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(aColor);

  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, mesh.idxBuf);
}

function drawMesh(mesh, model, view, proj) {
  const vp = mat4Multiply(proj, view);
  const mvp = mat4Multiply(vp, model);
  gl.uniformMatrix4fv(uMVP, false, new Float32Array(mvp));
  bindMesh(mesh);
  gl.drawElements(gl.TRIANGLES, mesh.count, gl.UNSIGNED_SHORT, 0);
}

// ====== Main loop ======
function update(dt) {
  if (!alive) return;

  // Controls
  const forward = keys["w"] || keys["arrowup"];
  const back = keys["s"] || keys["arrowdown"];
  const left = keys["a"] || keys["arrowleft"];
  const right = keys["d"] || keys["arrowright"];

  if (forward) car.speed += car.accel;
  if (back) car.speed -= car.accel*0.7;
  car.speed *= car.friction;
  if (car.speed > car.maxSpeed) car.speed = car.maxSpeed;
  if (car.speed < -car.maxSpeed*0.5) car.speed = -car.maxSpeed*0.5;

  if (left) car.rot += car.turnSpeed * (car.speed>=0?1:-1);
  if (right) car.rot -= car.turnSpeed * (car.speed>=0?1:-1);

  car.x += Math.sin(car.rot) * car.speed;
  car.z += Math.cos(car.rot) * car.speed;

  // Keep in arena
  const dist = Math.hypot(car.x, car.z);
  if (dist > arenaRadius-1) {
    const factor = (arenaRadius-1)/dist;
    car.x *= factor;
    car.z *= factor;
    car.speed *= 0.5;
  }

  // Enemies move
  for (const e of enemies) {
    e.x += e.vx;
    e.z += e.vz;

    // Bounce off arena edge
    const d = Math.hypot(e.x, e.z);
    if (d > arenaRadius-1.5) {
      const nx = e.x/d, nz = e.z/d;
      const dot = e.vx*nx + e.vz*nz;
      e.vx -= 2*dot*nx;
      e.vz -= 2*dot*nz;
    }

    // Slight random jitter
    e.vx += (Math.random()-0.5)*0.002;
    e.vz += (Math.random()-0.5)*0.002;
    const spd = Math.hypot(e.vx,e.vz);
    const maxE = 0.06;
    if (spd>maxE) { e.vx*=maxE/spd; e.vz*=maxE/spd; }

    // Collision with car
    const dx = e.x - car.x;
    const dz = e.z - car.z;
    if (dx*dx + dz*dz < 1.0) {
      alive = false;
      hud.textContent = "You crashed! Refresh to retry. Survival time: " +
        ((performance.now()-startTime)/1000).toFixed(1) + "s";
    }
  }

  // Occasionally spawn more enemies
  if (enemies.length < 20 && Math.random() < 0.01) spawnEnemy();

  if (alive) {
    const t = ((performance.now()-startTime)/1000).toFixed(1);
    hud.textContent = "WASD/Arrows to drive – Survive: " + t + "s";
  }
}

function render(time) {
  const dt = (time - lastTime) * 0.001;
  lastTime = time;

  update(dt);

  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.02,0.02,0.04,1);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = canvas.width / canvas.height;
  const proj = mat4Perspective(Math.PI/3, aspect, 0.1, 100.0);

  // Camera behind and above car
  const camDist = 6;
  const camHeight = 4;
  const cx = car.x - Math.sin(car.rot)*camDist;
  const cz = car.z - Math.cos(car.rot)*camDist;
  const cy = camHeight;
  const eye = [cx, cy, cz];
  const center = [car.x, car.y, car.z];
  const up = [0,1,0];
  const view = mat4LookAt(eye, center, up);

  // Ground
  let model = mat4Identity();
  model = mat4Translate(model, [0,0,0]);
  drawMesh(groundMesh, model, view, proj);

  // Car
  model = mat4Identity();
  model = mat4Translate(model, [car.x, car.y, car.z]);
  model = mat4RotateY(model, car.rot);
  drawMesh(carMesh, model, view, proj);

  // Enemies
  for (const e of enemies) {
    let m = mat4Identity();
    m = mat4Translate(m, [e.x, e.y, e.z]);
    drawMesh(enemyMesh, m, view, proj);
  }

  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>
